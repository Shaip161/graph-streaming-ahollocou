// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STREAMINGCLUSTERINGALHOLLOCOU_STREAMINFO_H_
#define FLATBUFFERS_GENERATED_STREAMINGCLUSTERINGALHOLLOCOU_STREAMINFO_H_

#include "flatbuffers/flatbuffers.h"

namespace StreamInfo {

struct Partition;
struct PartitionBuilder;

struct GraphMetadata;
struct GraphMetadataBuilder;

struct PartitionConfiguration;
struct PartitionConfigurationBuilder;

struct RunTime;
struct RunTimeBuilder;

struct ClusteringMetrics;
struct ClusteringMetricsBuilder;

struct MemoryConsumption;
struct MemoryConsumptionBuilder;

struct Partition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPH_METADATA = 4,
    VT_PARTITION_CONFIGURATION = 6,
    VT_RUNTIME = 8,
    VT_MEMORY_CONSUMPTION = 10,
    VT_CLUSTERING_METRICS = 12
  };
  const StreamInfo::GraphMetadata *graph_metadata() const {
    return GetPointer<const StreamInfo::GraphMetadata *>(VT_GRAPH_METADATA);
  }
  const StreamInfo::PartitionConfiguration *partition_configuration() const {
    return GetPointer<const StreamInfo::PartitionConfiguration *>(VT_PARTITION_CONFIGURATION);
  }
  const StreamInfo::RunTime *runtime() const {
    return GetPointer<const StreamInfo::RunTime *>(VT_RUNTIME);
  }
  const StreamInfo::MemoryConsumption *memory_consumption() const {
    return GetPointer<const StreamInfo::MemoryConsumption *>(VT_MEMORY_CONSUMPTION);
  }
  const StreamInfo::ClusteringMetrics *clustering_metrics() const {
    return GetPointer<const StreamInfo::ClusteringMetrics *>(VT_CLUSTERING_METRICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRAPH_METADATA) &&
           verifier.VerifyTable(graph_metadata()) &&
           VerifyOffset(verifier, VT_PARTITION_CONFIGURATION) &&
           verifier.VerifyTable(partition_configuration()) &&
           VerifyOffset(verifier, VT_RUNTIME) &&
           verifier.VerifyTable(runtime()) &&
           VerifyOffset(verifier, VT_MEMORY_CONSUMPTION) &&
           verifier.VerifyTable(memory_consumption()) &&
           VerifyOffset(verifier, VT_CLUSTERING_METRICS) &&
           verifier.VerifyTable(clustering_metrics()) &&
           verifier.EndTable();
  }
};

struct PartitionBuilder {
  typedef Partition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graph_metadata(flatbuffers::Offset<StreamInfo::GraphMetadata> graph_metadata) {
    fbb_.AddOffset(Partition::VT_GRAPH_METADATA, graph_metadata);
  }
  void add_partition_configuration(flatbuffers::Offset<StreamInfo::PartitionConfiguration> partition_configuration) {
    fbb_.AddOffset(Partition::VT_PARTITION_CONFIGURATION, partition_configuration);
  }
  void add_runtime(flatbuffers::Offset<StreamInfo::RunTime> runtime) {
    fbb_.AddOffset(Partition::VT_RUNTIME, runtime);
  }
  void add_memory_consumption(flatbuffers::Offset<StreamInfo::MemoryConsumption> memory_consumption) {
    fbb_.AddOffset(Partition::VT_MEMORY_CONSUMPTION, memory_consumption);
  }
  void add_clustering_metrics(flatbuffers::Offset<StreamInfo::ClusteringMetrics> clustering_metrics) {
    fbb_.AddOffset(Partition::VT_CLUSTERING_METRICS, clustering_metrics);
  }
  explicit PartitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Partition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Partition>(end);
    return o;
  }
};

inline flatbuffers::Offset<Partition> CreatePartition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<StreamInfo::GraphMetadata> graph_metadata = 0,
    flatbuffers::Offset<StreamInfo::PartitionConfiguration> partition_configuration = 0,
    flatbuffers::Offset<StreamInfo::RunTime> runtime = 0,
    flatbuffers::Offset<StreamInfo::MemoryConsumption> memory_consumption = 0,
    flatbuffers::Offset<StreamInfo::ClusteringMetrics> clustering_metrics = 0) {
  PartitionBuilder builder_(_fbb);
  builder_.add_clustering_metrics(clustering_metrics);
  builder_.add_memory_consumption(memory_consumption);
  builder_.add_runtime(runtime);
  builder_.add_partition_configuration(partition_configuration);
  builder_.add_graph_metadata(graph_metadata);
  return builder_.Finish();
}

struct GraphMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_NUM_NODES = 6,
    VT_NUM_EDGES = 8
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  uint64_t num_nodes() const {
    return GetField<uint64_t>(VT_NUM_NODES, 0);
  }
  uint64_t num_edges() const {
    return GetField<uint64_t>(VT_NUM_EDGES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint64_t>(verifier, VT_NUM_NODES, sizeof(uint64_t)) &&
           VerifyField<uint64_t>(verifier, VT_NUM_EDGES, sizeof(uint64_t)) &&
           verifier.EndTable();
  }
};

struct GraphMetadataBuilder {
  typedef GraphMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(GraphMetadata::VT_FILENAME, filename);
  }
  void add_num_nodes(uint64_t num_nodes) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_NUM_NODES, num_nodes, 0);
  }
  void add_num_edges(uint64_t num_edges) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_NUM_EDGES, num_edges, 0);
  }
  explicit GraphMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GraphMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GraphMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<GraphMetadata> CreateGraphMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    uint64_t num_nodes = 0,
    uint64_t num_edges = 0) {
  GraphMetadataBuilder builder_(_fbb);
  builder_.add_num_edges(num_edges);
  builder_.add_num_nodes(num_nodes);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<GraphMetadata> CreateGraphMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    uint64_t num_nodes = 0,
    uint64_t num_edges = 0) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return StreamInfo::CreateGraphMetadata(
      _fbb,
      filename__,
      num_nodes,
      num_edges);
}

struct PartitionConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartitionConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VMAX_START = 4,
    VT_VMAX_END = 6,
    VT_CONDITION = 8,
    VT_SEED = 10,
    VT_NITER = 12
  };
  uint32_t vmax_start() const {
    return GetField<uint32_t>(VT_VMAX_START, 0);
  }
  uint32_t vmax_end() const {
    return GetField<uint32_t>(VT_VMAX_END, 0);
  }
  uint32_t condition() const {
    return GetField<uint32_t>(VT_CONDITION, 0);
  }
  int32_t seed() const {
    return GetField<int32_t>(VT_SEED, 0);
  }
  uint32_t niter() const {
    return GetField<uint32_t>(VT_NITER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VMAX_START, sizeof(uint32_t)) &&
           VerifyField<uint32_t>(verifier, VT_VMAX_END, sizeof(uint32_t)) &&
           VerifyField<uint32_t>(verifier, VT_CONDITION, sizeof(uint32_t)) &&
           VerifyField<int32_t>(verifier, VT_SEED, sizeof(int32_t)) &&
           VerifyField<uint32_t>(verifier, VT_NITER, sizeof(uint32_t)) &&
           verifier.EndTable();
  }
};

struct PartitionConfigurationBuilder {
  typedef PartitionConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vmax_start(uint32_t vmax_start) {
    fbb_.AddElement<uint32_t>(PartitionConfiguration::VT_VMAX_START, vmax_start, 0);
  }
  void add_vmax_end(uint32_t vmax_end) {
    fbb_.AddElement<uint32_t>(PartitionConfiguration::VT_VMAX_END, vmax_end, 0);
  }
  void add_condition(uint32_t condition) {
    fbb_.AddElement<uint32_t>(PartitionConfiguration::VT_CONDITION, condition, 0);
  }
  void add_seed(int32_t seed) {
    fbb_.AddElement<int32_t>(PartitionConfiguration::VT_SEED, seed, 0);
  }
  void add_niter(uint32_t niter) {
    fbb_.AddElement<uint32_t>(PartitionConfiguration::VT_NITER, niter, 0);
  }
  explicit PartitionConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartitionConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartitionConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartitionConfiguration> CreatePartitionConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t vmax_start = 0,
    uint32_t vmax_end = 0,
    uint32_t condition = 0,
    int32_t seed = 0,
    uint32_t niter = 0) {
  PartitionConfigurationBuilder builder_(_fbb);
  builder_.add_niter(niter);
  builder_.add_seed(seed);
  builder_.add_condition(condition);
  builder_.add_vmax_end(vmax_end);
  builder_.add_vmax_start(vmax_start);
  return builder_.Finish();
}

struct RunTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RunTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IO_TIME = 4,
    VT_MAPPING_TIME = 6,
    VT_TOTAL_TIME = 8
  };
  double io_time() const {
    return GetField<double>(VT_IO_TIME, 0.0);
  }
  double mapping_time() const {
    return GetField<double>(VT_MAPPING_TIME, 0.0);
  }
  double total_time() const {
    return GetField<double>(VT_TOTAL_TIME, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_IO_TIME, sizeof(double)) &&
           VerifyField<double>(verifier, VT_MAPPING_TIME, sizeof(double)) &&
           VerifyField<double>(verifier, VT_TOTAL_TIME, sizeof(double)) &&
           verifier.EndTable();
  }
};

struct RunTimeBuilder {
  typedef RunTime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_io_time(double io_time) {
    fbb_.AddElement<double>(RunTime::VT_IO_TIME, io_time, 0.0);
  }
  void add_mapping_time(double mapping_time) {
    fbb_.AddElement<double>(RunTime::VT_MAPPING_TIME, mapping_time, 0.0);
  }
  void add_total_time(double total_time) {
    fbb_.AddElement<double>(RunTime::VT_TOTAL_TIME, total_time, 0.0);
  }
  explicit RunTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RunTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RunTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<RunTime> CreateRunTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    double io_time = 0.0,
    double mapping_time = 0.0,
    double total_time = 0.0) {
  RunTimeBuilder builder_(_fbb);
  builder_.add_total_time(total_time);
  builder_.add_mapping_time(mapping_time);
  builder_.add_io_time(io_time);
  return builder_.Finish();
}

struct ClusteringMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClusteringMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCORE = 4,
    VT_CLUSTERING_AMOUNT = 6
  };
  double score() const {
    return GetField<double>(VT_SCORE, 0.0);
  }
  uint64_t clustering_amount() const {
    return GetField<uint64_t>(VT_CLUSTERING_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCORE, sizeof(double)) &&
           VerifyField<uint64_t>(verifier, VT_CLUSTERING_AMOUNT, sizeof(uint64_t)) &&
           verifier.EndTable();
  }
};

struct ClusteringMetricsBuilder {
  typedef ClusteringMetrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_score(double score) {
    fbb_.AddElement<double>(ClusteringMetrics::VT_SCORE, score, 0.0);
  }
  void add_clustering_amount(uint64_t clustering_amount) {
    fbb_.AddElement<uint64_t>(ClusteringMetrics::VT_CLUSTERING_AMOUNT, clustering_amount, 0);
  }
  explicit ClusteringMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClusteringMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClusteringMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClusteringMetrics> CreateClusteringMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    double score = 0.0,
    uint64_t clustering_amount = 0) {
  ClusteringMetricsBuilder builder_(_fbb);
  builder_.add_clustering_amount(clustering_amount);
  builder_.add_score(score);
  return builder_.Finish();
}

struct MemoryConsumption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MemoryConsumptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OVERALL_MAX_RSS = 4
  };
  int64_t overall_max_rss() const {
    return GetField<int64_t>(VT_OVERALL_MAX_RSS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OVERALL_MAX_RSS, sizeof(uint64_t)) &&
           verifier.EndTable();
  }
};

struct MemoryConsumptionBuilder {
  typedef MemoryConsumption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_overall_max_rss(int64_t overall_max_rss) {
    fbb_.AddElement<int64_t>(MemoryConsumption::VT_OVERALL_MAX_RSS, overall_max_rss, 0);
  }
  explicit MemoryConsumptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MemoryConsumption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemoryConsumption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemoryConsumption> CreateMemoryConsumption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t overall_max_rss = 0) {
  MemoryConsumptionBuilder builder_(_fbb);
  builder_.add_overall_max_rss(overall_max_rss);
  return builder_.Finish();
}

inline const StreamInfo::Partition *GetPartition(const void *buf) {
  return flatbuffers::GetRoot<StreamInfo::Partition>(buf);
}

inline const StreamInfo::Partition *GetSizePrefixedPartition(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<StreamInfo::Partition>(buf);
}

inline bool VerifyPartitionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<StreamInfo::Partition>(nullptr);
}

inline bool VerifySizePrefixedPartitionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<StreamInfo::Partition>(nullptr);
}

inline void FinishPartitionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<StreamInfo::Partition> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPartitionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<StreamInfo::Partition> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace StreamInfo

#endif  // FLATBUFFERS_GENERATED_STREAMINGCLUSTERINGALHOLLOCOU_STREAMINFO_H_
